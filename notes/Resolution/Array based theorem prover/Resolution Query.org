#+STARTUP: showall
* Purpose:
** Find example expressions that meet criteria

* Negate the query
** Work forward to find where term is resolved out: look for steps with query literal as input.
** Include side literals as conditions in result
** Eg. Query (Eval T) => ~exist x.X = eval (Y)
*** X is generated, find the value assigned to that among the Vbv for the proof.
**** Include the other vbl values for context, sbst into their clauses
**** Map the clauses forward to use the assigned vbl values
**** X will be unified with the lhs of equations like x^2 = (eval (sqr x))
*** Depth first search means smaller solutions are found first
*** Break eval(T) into cases
*** X = eval (car (Y)) && y = cons(x, z)
** How to work back from final K to the K that actually refutes the original axioms?
*** Want all the axioms unified together with the term that refutes them simultaneously
*** The K's trace back to some side literal on a predecessor axiom
*** In goal to be refuted is ~exist x.P(x), then want example x.
*** Each step assigns value terms to vbls. Make those assignments in previous clauses.
*** Each literal in original axioms gets refuted somewhere in the proof tree. 
*** Find the one that is inside the query literal
* Multiple values
** Create a spr, let it run in background, report results when it finds them
** Each proof is a vbv.
*** How to trace back to previous vbv-s?
*** What do the vbls mean? Values to assign to original clauses
*** Map back to original infix
** That will generate a series of possible answers, and there could be an infinity of them
*** How to collapse down to a closed form?
**** If there are terms being substituted into separate parts, they can be a cartesian product
**** There could be an arbitrarily complex structure
**** Could take results as they are found and factor them


* Composition of Vbv
** A vbv has a list of vba, to compose, apply the value of the each vbl to the occurrences in the other
* Can also apply to other functions, such as
** Query(Transform(tree, xid))
** Doesn't need to be procedural
* 
* Query handler: given an predicate expression with set of axioms, respond with expression of all terms that satisfy that. e.g. p(?x ,?y, c) => cnf of equations of x,y expressed as constants
** Assert that query predicate is false. (create clause with it as left)
** Can have other terms Ored and ANDed with query (via SKO)
** Resolution tree can be reformatted as a collection of clauses that are substituted and then ANDed together. 
*** The substitution for each clause is the composition down to the root of the tree from where it was first used.
*** The predication in which that variable appears tells something about that value.
*** When clause used multiple times, they containing predications are ANDed in the proof, so the predications are ANDed in the query result.
*** There could be multiple proofs: those are ORed.
** Flag on Res to keep on going for more proofs.
** Query feature
*** Do as clause first, then infix.
*** Query setting on Res to do callback with query results. Each query refers to list of clauses and variable in them. Result is cumulative term for variable in predications. Callback returns flag to continue.
**** (query (x ..) (clause)) - create acs, but add to res. Default callback (deterimine by keyword query).
** Puzzle solver: query for values: (color ?x c). Multiple queries all go as neg terms. It will have to refute them all.
** Goal is ability to ask what is value of property after some event, and generalizations of that.
*** e.g. assert that value cannot be X when some other condition (state) is true
**** How to get the sequence of steps that need to happen to get that state? Is it built up as a term?
*** Find minimum over possible states? Enumerate, evaluate
*** Another kind of query: return list of statements that would complete the sequent
**** Why is a term not a contradiction?
*** Different clauses other than empty clause can represent intermediate goals that can be reached multiple ways. These can be hierarchical, with a DAG connecting them.
**** How to define a series of events to be generated by a proof? Control priorities?
** Incremental query
*** Base Res does not have a refutation - stop it via the callback. Add a special term to the inverted clause that causes it to fail, but when the clause is empty except for that term, then stop the query. 
*** Then run query using queue that sits on top of base Res to capture new clauses
** Really want more facts object objects for which certain given facts are true. Ax:Px -> ?
*** P(x) may be the result of other clauses.
*** Filter the all clauses, only show ones with ~P(X), or have a set of terms that implies ~P(x). Even if those terms are pos.
**** Remove clauses that are true even without the ~P(x).
**** How to tell if ~P(x) is implied from another set of terms?
***** Look for clauses that have only P(x) on pos side
***** Can they be replaced by ~P(x) and still have valid clause? Yes, but it is weaker.
**** What if query P(x) <-> Q(x) | R(x) ?  &? f(x)?
***** These are important because they describe what is true in more complex conditions.
*** Is the generated set of clauses complete? Assuming there is no refutation.
**** Suppose there is a result that is missing, and there is no refutation. Add negation of that result?
*** Example: what can cause Q(x) to be true? Is this basically the same as ~P(x) case?
*** Example:  info that is unique about all a such that: (S s1 a)
*** How to schedule iteration of base clauses and query?


* What resolution does
** Consider the space of the quantified variables.
** A model is an assignment of values to all constants functions, etc. to a point in the space. 
** Each given clause covers the allowed models, meaning that at least one of the predicate terms in each clause is true in every allowed model.
** A cut takes two clauses with a term and its negation and unions the other terms in the two clauses. Since the remaining terms in one clause covered the allowed models descried by the negation of the term, and the other covered the allowed models described by the positive term, the union without that either term or its negation still covers the allowed models.
** To prove P(x), add a clause ~P(x). If P(x) is in the allowed region described by the clauses, the ~P(x) extends that to the complete space of models, and so the empty clause can be derived.
* Query
** A query says show the reason why all models in the query region are allowed. If a certain set of terms subsume the other clauses that establish the query space, then just show those.
** There might be more elaborate ways of establishing that. When to stop?
** Consider part of the true space called Q(x). That means those states are allowed by the operations. Assert ~Q(x), so now there is a proof of Q(x).
** Doing proof starting from the non-query part of space means finding terms that are true in the gap, which is the query space.
** What to show why those points are allowed: prove they follow from the rules and facts.
** One or more of the terms unioned in during the prove provide the cover for the query part of the space. 
*** Exclude the terms that are inconsistent with the query part: resolution to empty clause happens starting with negation of query and negation of those terms.
** A simple query will be covered by one of the given clauses, that just means that clause is the reason why the query region is allowed. In other cases, a series of lefts will be used in the proof. Those can be filtered down. Addition clauses will be needed to establish those lefts. 
* Generate code:
** The query asks if there is a series of steps that guarantee a given result from a given starting point. The response gives a path. Conditionals seem reasonable. While requires induction, but transformation based code does not need iteration, just foreach.
** What is an example that can illustrate generated code? A set of xfi, xbi?

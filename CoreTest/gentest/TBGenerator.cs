// OWNER: GJG
// #define DEBUG_PATH

using reslab;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Reflection;

namespace WBS
{

    public class Svl
    {
        public void Add(Sdi sdi) { throw new NotImplementedException(); }

    }

    public class Sde
    {

    }

    public class SMState
    {
        public int cActions;
        public SMAction this[int i]
        {
            get { throw new NotImplementedException(); }
        }
    }

    public class SMStateMachine
    {
        public SMStateMachine(Sdi sdiTb, Trc trc) { }
    }

    public class SMAction
    {

    }

    public class Smc : Imc
    {
        public SMState CurrentState;
        public bool fTerminated;
        public bool fActions;
        public void SetStateMachine(SMStateMachine smsMachine) { }
        public void Forward(SMAction action) { throw new NotImplementedException(); }
        public void Backtrack() { throw new NotImplementedException(); }
        public void EnterShutdownMode() { throw new NotImplementedException(); }
    }


    /*
     * Construct a Node or Sdi
     */
    public abstract class Tqdb : Tqd
    {

        private readonly Tqd _tqdIsa;


        private Tqd _tqdPayload;


        private readonly List<Tqdt> _rgtqdt = new List<Tqdt>(); // values for traits of contructed node


        public virtual IEnumerable<Tqdt> rgtqdt() { return _rgtqdt; }


        protected Tqdb(string stName, Tqd tqdIsa, Tqd tqdPayload, params Tqdt[] rgtqdt) : base(stName)
        {
            _tqdIsa = tqdIsa;
            _tqdPayload = tqdPayload;
            if (rgtqdt != null)
            {
                foreach (Tqdt tqdt in rgtqdt)
                    _rgtqdt.Add(tqdt);
            }
        }


        public virtual Tqd tqdIsa() { return _tqdIsa; }


        public virtual Tqd tqdPayload() { return _tqdPayload; }


        public Tqdb Payload(Tqd tqdPayload)
        {
            _tqdPayload = tqdPayload;
            return this;
        }



        public Tqdb Trait(Nid nid, params Tqd[] rgtqdValue)
        {
            Tqdtrv Tqdtrv = new Tqdtrv(tqdvLookup(nid), rgtqdValue);
            _rgtqdt.Add(Tqdtrv);
            return this;
        }



        public Tqdb Trait(Type typeNid, params Tqd[] rgtqdValue)
        {
            Tqdtrv Tqdtrv = new Tqdtrv(tqdvLookup(typeNid), rgtqdValue);
            _rgtqdt.Add(Tqdtrv);
            return this;
        }



        public Tqdb Field(string stFieldName, params Tqd[] rgtqdValue)
        {
            Tqdtrv Tqdtrv = new Tqdtrv(new Tqdv(stFieldName, stFieldName), rgtqdValue);
            _rgtqdt.Add(Tqdtrv);
            return this;
        }
    }

    /**
     * Create a Tqss, which will Construct an Sdi
     */
    public class Tqds : Tqdb
    {
        public Tqds(string stName, Tqd tqdIsa, Tqd tqdPayload = null, params Tqdt[] rgtqdt)
            : base(stName, tqdIsa, tqdPayload, rgtqdt)
        {
        }

        public override Tqs TqsMake(Tqs tqsParent)
        {
            return new Tqss(tqsParent, this);
        }

        public static Tqds tqdBuild(string stName, Type typeIsa)
        {
            return new Tqds(stName, tqdvLookupSdv(typeIsa));
        }
    }

    /*
     * Construct a trait/rgsdiValue pair with rgsdiValue, base class.
     */
    public abstract class Tqdt : Tqd
    {

        public readonly Tqd tqdTrait;

        protected Tqdt(Tqd tqdTrait) : base(tqdTrait.stName)
        {
            this.tqdTrait = tqdTrait;
        }
    }

    /*
     * Construct a trait/rgsdiValue pair with nodes as provided by given iterators
     */
    public class Tqdtrv : Tqdt
    {

        public readonly List<Tqd> rgtqdValue;


        public Tqdtrv(Tqd tqdTrait, params Tqd[] rgtqdValue)
            : base(tqdTrait)
        {
            this.rgtqdValue = new List<Tqd>();
            foreach (Tqd tqd in rgtqdValue)
                this.rgtqdValue.Add(tqd);
        }

        //Not used.

        public Tqdtrv(Tqd tqdTrait, List<Tqd> rgtqdValue)
            : base(tqdTrait)
        {
            this.rgtqdValue = rgtqdValue;
        }

        public override Tqs TqsMake(Tqs tqsParent)
        {
            return new Tqstrv(tqsParent, this);
        }
    }

    /*
     * Construct a list where rgsdiValue comes from an enumeration.
     * Currently this is treated as a fixed rgsdiValue that is generated by enumeration one time.
     */
    public class Tqdte : Tqdt
    {

        public readonly Tqd tqdValue;

        // Not used.

        public Tqdte(Tqd tqdTrait, Tqd tqdValue)
            : base(tqdTrait)
        {
            this.tqdValue = tqdValue;
        }

        public override Tqs TqsMake(Tqs tqsParent)
        {
            return new Tqste(tqsParent, this);
        }
    }

    /**
     * Generate a series of test cases based on transitions through a state machine.
     */
    public class Tqdm : Tqd
    {

        public readonly Tqd tqdTB;


        public readonly Tqd tqdPath;

        public Tqdm(string stName, Tqd tqdTB, Tqd tqdPath)
            : base(stName)
        {
            this.tqdTB = tqdTB;
            this.tqdPath = tqdPath;
        }

        public override Tqs TqsMake(Tqs tqsParent)
        {
            return new Tqsm(tqsParent, this);
        }
    }

    /**
     * Generate a rgPath of transitions through a state machine
     */
    public abstract class Tqdp : Tqd
    {

        public readonly Tqdpt tqdpt;

        public readonly int cMaxPathLength;


        public readonly Trc trcInitial;

        protected Tqdp(string stName, Tqdpt tqdpt, int cMaxPathLength, Trc trcInitial = null)
            : base(stName)
        {
            this.cMaxPathLength = cMaxPathLength;
            this.tqdpt = tqdpt;
            this.trcInitial = trcInitial;
        }


        protected abstract Tqsp tqspMake(Tqs tqsParent);

        public override Tqs TqsMake(Tqs tqsParent)
        {
            return tqspMake(tqsParent);
        }
    }

    /*
     * Generates an exhaustive set of paths of transitions through a state machine
     */
    public class Tqdpe : Tqdp
    {
        public Tqdpe(string stName, Tqdpt tqdpt, int cMaxPathLength, Trc trcInitial = null)
            : base(stName, tqdpt, cMaxPathLength, trcInitial)
        {
        }

        protected override Tqsp tqspMake(Tqs tqsParent)
        {
            return new Tqspe(tqsParent, this);
        }
    }

    /*
    * Generates a random set of paths of transitions through a state machine
    */
    public class Tqdpr : Tqdp
    {
        public Tqdpr(string stName, Tqdpt tqdpt, int cMaxPathLength, Trc trcInitial = null)
            : base(stName, tqdpt, cMaxPathLength, trcInitial)
        {
        }

        protected override Tqsp tqspMake(Tqs tqsParent)
        {
            return new Tqspr(tqsParent, this);
        }
    }

    public abstract class Tqsb : Tqs
    {

        protected readonly Tqs tqsIsa;


        protected readonly Tqs tqsPayload;


        protected List<Tqs> rgtqsChildren;

        protected Tqsb(Tqs tqsParent, Tqdb tqdb)
            : base(tqsParent, tqdb)
        {
            tqsIsa = tqdb.tqdIsa().TqsMake(this);
            Tqd tqdPayload = tqdb.tqdPayload();
            IEnumerable<Tqdt> rgtqdt = tqdb.rgtqdt();

            if (tqdPayload != null)
                tqsPayload = tqdPayload.TqsMake(this);
            rgtqsChildren = new List<Tqs>();
            foreach (Tqdt tqdt in rgtqdt)
                rgtqsChildren.Add(tqdt.TqsMake(this));
        }


        public override KVisitResult Accept(Tqv tqvVisitor, Ivd ivdData)
        {
            if (AcceptRgtqs<Tqs>(this, tqvVisitor, rgtqsChildren, ivdData) == KVisitResult.Stop)
                return KVisitResult.Stop;

            if (tqsPayload != null
                && tqsPayload.Accept(tqvVisitor, ivdData) == KVisitResult.Stop
                && CleanupRgtqs(tqvVisitor, rgtqsChildren, 0, ivdData) == KInitializeResult.Succeeded)
                return KVisitResult.Stop;

            if (tqsIsa.Accept(tqvVisitor, ivdData) == KVisitResult.Stop
                && ((tqsPayload == null) || (tqvVisitor.Cleanup(tqsPayload, ivdData) == KInitializeResult.Succeeded))
                && CleanupRgtqs(tqvVisitor, rgtqsChildren, 0, ivdData) == KInitializeResult.Succeeded)
                return KVisitResult.Stop;

            return tqvVisitor.Visit(this, ivdData);
        }
    }

    /**
     * Create an Sdi
     */
    public class Tqss : Tqsb
    {
        public Tqss(Tqs tqsParent, Tqds tqds)
            : base(tqsParent, tqds)
        {
        }


        public static Sdi sdiMake(object objTypeId)
        {
            Sdi sdi;
            if (objTypeId is Sdv)
            {
                Sdv sdv = (Sdv)objTypeId;
                objTypeId = sdv.typeIn;
                Debug.Assert(objTypeId != null);
                object instance = Activator.CreateInstance((Type)objTypeId);
                sdi = (Sdi)instance;
                sdi.sdvDef = sdv;
                // objIsa not implemented
            }
            else if (objTypeId is Type) // marked by SdvNone
            {
                object instance = Activator.CreateInstance((Type)objTypeId);
                sdi = (Sdi)instance;
            }
            else
            {
                return null;
            }
            return sdi;
        }


        public override object objCurrent(Imc imc)
        {
            // Construct a node each time.

            object objTypeId = tqsIsa.objCurrent(imc);
            Sdi sdi = sdiMake(objTypeId);
            if (sdi == null)
            {
                Debug.Assert(tqsIsa != null);
                Debug.Assert(tqsIsa.tqdDef != null);
                throw new InvalidDataException("unrecognized isa  " + tqsIsa.tqdDef.stName);
            }
            if (imc != null)
                imc.CreateInstance(objTypeId, sdi);
            if (tqsPayload != null)
            {
                object objPayload = tqsPayload.objCurrent(imc);
                sdi.SetPayload(objPayload);
                if (imc != null)
                    imc.SetPayload(sdi, objPayload);
            }

            foreach (Tqs tqsChild in rgtqsChildren)
            {
                Itv itvChild = (Itv)tqsChild;
                itvChild.SetValueOnAttribute(imc, sdi);
            }

            sdi.AfterBuilt();

            return sdi;
        }
    }

    public interface Itv
    {

        void SetValueOnAttribute(Imc imc, Sdi sdiParent);
    }

    public class Tqstrv : Tqs, Itv
    {

        private readonly Tqs tqsTrait;


        private readonly List<Tqs> rgtqsChildren;

        public Tqstrv(Tqs tqsParent, Tqdtrv tqdtrv)
            : base(tqsParent, tqdtrv)
        {
            tqsTrait = tqdtrv.tqdTrait.TqsMake(this);
            rgtqsChildren = new List<Tqs>(tqdtrv.rgtqdValue.Count);
            foreach (Tqd tqd in tqdtrv.rgtqdValue)
                rgtqsChildren.Add(tqd.TqsMake(this));
        }


        public override KVisitResult Accept(Tqv tqvVisitor, Ivd ivdData)
        {
            if (AcceptRgtqs<Tqs>(this, tqvVisitor, rgtqsChildren, ivdData) == KVisitResult.Stop)
                return KVisitResult.Stop;
            if (tqsTrait.Accept(tqvVisitor, ivdData) == KVisitResult.Stop
                && CleanupRgtqs(tqvVisitor, rgtqsChildren, 0, ivdData) == KInitializeResult.Succeeded)
                return KVisitResult.Stop;
            return tqvVisitor.Visit(this, ivdData);
        }


        public override object objCurrent(Imc imc)
        {
            return null; // not used. Tqsn bypasses this for efficiency.
        }

        /**
         * Add the values described by this trait and children to the given sdiParent.
         */

        public void SetValueOnAttribute(Imc imc, Sdi sdiParent)
        {
            // Nid trait = traitCurrent();
            object objFieldId = tqsTrait.objCurrent(imc);
            FieldInfo fi = fiFromId(sdiParent, objFieldId);
            if (fi.FieldType == typeof(Svl))
            {
                Svl svl = (Svl)fi.GetValue(sdiParent);
                foreach (Tqs tqsChild in rgtqsChildren)
                {
                    var objChild = tqsChild.objCurrent(imc);
                    svl.Add((Sdi)objChild);
                    if (imc != null)
                        imc.AddValueOnAttribute(sdiParent, objFieldId, objChild);
                }
            }
            else
            {
                if (rgtqsChildren.Count != 1)
                    throw new InvalidDataException("require exactly one value");
                object objValue = rgtqsChildren[0].objCurrent(imc);
                fi.SetValue(sdiParent, objValue);
                if (imc != null)
                    imc.SetValueOnAttribute(sdiParent, objFieldId, objValue);
            }
        }


        private static FieldInfo fiFromId(Sdi sdiParent, object objFieldId)
        {
            if (objFieldId is Nid)
                return sdiParent.fiFindField((Nid)objFieldId);
            else if (objFieldId is Type)
                return sdiParent.fiFindField(Sdv.tFind<Nid>((Type)objFieldId, Sdv.stNidFieldName));
            else if (objFieldId is string)
            {
                Type typeParent = sdiParent.GetType();
                return typeParent.GetField((string)objFieldId);
            }
            else
                throw new InvalidDataException("unsupported type of field identifier: " + objFieldId.GetType());
        }


        public static void SetFieldValue(Sdi sdiParent, object objFieldId, object objValue)
        {
            FieldInfo fi = fiFromId(sdiParent, objFieldId);
            fi.SetValue(sdiParent, objValue);
        }


        public static void AddFieldValue(Sdi sdiParent, object objFieldId, object objValue)
        {
            FieldInfo fi = fiFromId(sdiParent, objFieldId);
            Svl svl = (Svl)fi.GetValue(sdiParent);
            svl.Add((Sdi)objValue);
        }
    }

    public class Tqste : Tqs
    {

        private List<Object> rgobjCurrent;

        public Tqste(Tqs tqsParent, Tqdte tqdte)
            : base(tqsParent, tqdte)
        {
            rgobjCurrent = null;
        }

        public override KInitializeResult fDoInitialize(Ivd ivdData)
        {
            Tqs tqsLocal = tqdDef.TqsMake(this);
            rgobjCurrent = new List<Object>();
            foreach (var objLocal in tqsLocal.en_objGenerate(ivdData))
                rgobjCurrent.Add(tqsLocal.objCurrent(ImcGet(ivdData)));

            return KInitializeResult.Succeeded;
        }


        public override KVisitResult Accept(Tqv tqvVisitor, Ivd ivdData)
        {
            return tqvVisitor.Visit(this, ivdData);
        }


        public override object objCurrent(Imc imc)
        {
            return rgobjCurrent;
        }
    }

    /**
     * 
     * Manage the iteration over TB and Tqsp.
     * For each TB and rgPath, this makes a Tqdp for that combo.
     * A Tqsp provides a strategy for choosing paths and performs the rgPath iteration given a specific TB.
     */
    public class Tqsm : Tqs
    {

        public Tqs tqsTB;


        protected Tqs tqsPath;  // each value can generate its own series of paths from the TB that comes from tqsTB


        private Tqs tqpPathIterator;  // each iteration is a rgPath starting from the current TB that is obtained from tqsTB

        public Tqsm(Tqs tqsParent, Tqdm tqdm)
            : base(tqsParent, tqdm)
        {
            tqsTB = null;
            tqsPath = null;
            tqpPathIterator = null;
        }

        public override KInitializeResult fDoInitialize(Ivd ivdData)
        {
            Tqdm tqdm = (Tqdm)tqdDef;
            Debug.Assert(tqdm != null);
            tqsTB = tqdm.tqdTB.TqsMake(this);
            if (tqsTB.fInitialize(ivdData) != KInitializeResult.Succeeded)
                return KInitializeResult.Failed;
            tqsPath = tqdm.tqdPath.TqsMake(this);
            if (tqsPath.fInitialize(ivdData) != KInitializeResult.Succeeded)
                return KInitializeResult.Failed;

            Tqdp tqdp = (Tqdp)tqsPath.objCurrent(ImcGet(ivdData));
            tqpPathIterator = tqdp.TqsMake(this);
            if (tqpPathIterator.fInitialize(ivdData) != KInitializeResult.Succeeded)
                return KInitializeResult.Failed;
            return KInitializeResult.Succeeded;
        }


        public override KVisitResult Accept(Tqv tqvVisitor, Ivd ivdData)
        {
            if (tqpPathIterator != null
                && tqvVisitor.Visit(tqpPathIterator, ivdData) == KVisitResult.Stop)
                return KVisitResult.Stop;

            if (tqsPath != null && tqsPath.Accept(tqvVisitor, ivdData) == KVisitResult.Stop)
            {
                if (tqpPathIterator != null
                    && tqvVisitor.Cleanup(tqpPathIterator, ivdData) == KInitializeResult.Failed)
                    return KVisitResult.Continue;
                return KVisitResult.Stop;
            }

            if (tqsTB != null && tqsTB.Accept(tqvVisitor, ivdData) == KVisitResult.Stop)
            {
                if (tqvVisitor.Cleanup(tqsPath, ivdData) == KInitializeResult.Failed)
                    return KVisitResult.Continue;
                if (tqpPathIterator != null
                    && tqvVisitor.Cleanup(tqpPathIterator, ivdData) == KInitializeResult.Failed)
                    return KVisitResult.Continue;
                return KVisitResult.Stop;
            }
            return tqvVisitor.Visit(this, ivdData);
        }

        /**
         * Build the current test case.
         */

        public override object objCurrent(Imc imc)
        {
            Debug.Assert(tqpPathIterator != null);
            return tqpPathIterator.objCurrent(imc);
        }
    }

    public class Tqdpt : Tqd
    {

        public Tqr tqrRandom;

        public Tqdpt(string stName, Tqr tqrRandom)
            : base(stName)
        {
            this.tqrRandom = tqrRandom;
        }

        public override Tqs TqsMake(Tqs tqsParent) { throw new NotImplementedException(); }
    }

    /**
     * Iterator over transitions in a single state of the state machine.
     * Using Tqs is a bit of overkill since there is no Tqd (yet), but keeps things consistent.
     */
    public abstract class Tqspt : Tqs
    {

        protected readonly SMState smStateSource;


        private readonly IEnumerator<Tqx> et_tqxAllowedIterator;

        protected Tqspt(Tqs tqsParent, Tqd tqdDef, SMState smStateSource) : base(tqsParent, tqdDef)
        {
            this.smStateSource = smStateSource;
            et_tqxAllowedIterator = et_tqxAllowedEnumerator();
        }


        public override KVisitResult Accept(Tqv tqvVisitor, Ivd ivdData)
        {
            return tqvVisitor.Visit(this, ivdData);
        }

        public override KVisitResult fDoMoveNext(Ivd ivdData)
        {
            return et_tqxAllowedIterator.MoveNext() ? KVisitResult.Stop : KVisitResult.Continue;
        }


        public override object objCurrent(Imc imc)
        {
            return et_tqxAllowedIterator.Current;
        }


        public abstract IEnumerator<Tqx> et_tqxAllowedEnumerator();
    }

    public class Tqspte : Tqspt
    {
        public Tqspte(Tqs tqsParent, Tqd tqdDef, SMState smStateSource)
            : base(tqsParent, tqdDef, smStateSource)
        {
        }

        public override IEnumerator<Tqx> et_tqxAllowedEnumerator()
        {
            int nSize = smStateSource.cActions;

            for (int i = 0; i < nSize; i++)
            {
                SMAction action = smStateSource[i];
                Tqx tqx = new Tqx(action);
                yield return tqx;
            }
        }
    }

    public class Tqsptr : Tqspt
    {
        public Tqsptr(Tqs tqsParent, Tqd tqdDef, SMState smStateSource)
            : base(tqsParent, tqdDef, smStateSource)
        {
            Debug.Assert(tqdDef != null);
        }

        public override IEnumerator<Tqx> et_tqxAllowedEnumerator()
        {
            Tqdpt tqdpt = (Tqdpt)tqdDef;
            Debug.Assert(tqdpt != null);

            int nSize = smStateSource.cActions;
            int pick = tqdpt.tqrRandom.random.Next(nSize);
            SMAction action = smStateSource[pick];
            Tqx tqx = new Tqx(action);
            yield return tqx;
        }
    }

    public interface IModelRoot
    {
        void EnterShutdownMode();
    }

    /**
     * Generate an instance of state machine model from a given initial state,
     * then on each iteration return a list of transitions through that machine for that model.
     */
    public abstract class Tqsp : Tqs
    {

        protected readonly List<Tqspt> rgtqtPath;


        private Sdi sdiTB;

        protected readonly int cMaxPathLength;

        protected Smc smc;

        protected Tqsp(Tqs tqsParent, Tqdp tqdp) : base(tqsParent, tqdp)
        {
            rgtqtPath = new List<Tqspt>();
            sdiTB = null;
            cMaxPathLength = tqdp.cMaxPathLength;
        }


        public override KVisitResult Accept(Tqv tqvVisitor, Ivd ivdData)
        {
            if (AcceptRgtqs<Tqspt>(this, tqvVisitor, rgtqtPath, ivdData) == KVisitResult.Stop)
                return KVisitResult.Stop;
            return tqvVisitor.Visit(this, ivdData);
        }

        public override KVisitResult fMoveNext(Ivd ivdData)
        {
            return fDoMoveNext(ivdData);
        }

        public override KInitializeResult fDoInitialize(Ivd ivdData)
        {
            Tqsm tqsm = (Tqsm)tqsParent;
            Debug.Assert(tqsm != null);
            Debug.Assert(tqsm.tqsTB != null);
            Debug.Assert(tqdDef != null);
            smc = (Smc)(ivdData.imcGet());
            Sdi.Init();   // before the TB is created
            sdiTB = (Sdi)(tqsm.tqsTB.objCurrent(smc));  // provides initial TB for state machine
            Debug.Assert(sdiTB != null);
            SMStateMachine smsMachine = new SMStateMachine(sdiTB, ((Tqdp)tqdDef).trcInitial);
            smc.SetStateMachine(smsMachine);

            // Console.WriteLine("fDoInitialize - Create StateMachine");

            fDoMoveNext(ivdData);

            return KInitializeResult.Succeeded;
        }

        /**
         * Build the current test case.
         */

        public override object objCurrent(Imc imc)
        {
            return null; // not used, Smc is passed in as ivdData
        }


        protected List<object> Report()
        {
            Debug.Assert(sdiTB != null);
            return new List<object>() { sdiTB.Payload, cMaxPathLength };
        }
    }

    /*
     * Generate an instance of state machine model from a given initial state,
     * then generate exhaustive sequences of transitions through that machine for that model.
     */
    public class Tqspe : Tqsp
    {
        private bool fForward;

        public Tqspe(Tqs tqsParent, Tqdp tqdp) : base(tqsParent, tqdp)
        {
            fForward = false;
        }

        public override KInitializeResult fDoInitialize(Ivd ivdData)
        {
            fForward = true;
            return base.fDoInitialize(ivdData);
        }

        // find the last step in the current rgPath that can be replaced and go forward from there
        public override KVisitResult fDoMoveNext(Ivd ivdData)
        {
            // fForward will be true only on the first call.
            if (fForward)
            {
#if DEBUG_PATH
                Console.WriteLine("Going forward");
#endif
                if (cMaxPathLength == 0)
                    goto Backtracking; // Handle corner case.
            }
            else
            {
#if DEBUG_PATH
                Console.WriteLine("Not going forward");
#endif
                goto TestIfFinished;
            }


        AppendIterator:
#if DEBUG_PATH
            Console.WriteLine("Extending rgPath from last vertex by creating new iterator");
#endif
            // Append a new iterator so we can extend the rgPath from the current state.
            Debug.Assert(tqdDef != null);
            Tqspt tqsptNew = new Tqspte(this, ((Tqdp)tqdDef).tqdpt, smc.CurrentState);
            if (tqsptNew.fInitialize(ivdData) != KInitializeResult.Failed)
                rgtqtPath.Add(tqsptNew);
            else
                goto Backtracking;

            NextEdge:
#if DEBUG_PATH
            Console.WriteLine("Getting new edge from last iterator");
#endif
            // Get the next edge from the last iterator.
            Tqspt tqsptTail = rgtqtPath[rgtqtPath.Count - 1];
            if (tqsptTail.fMoveNext(ivdData) == KVisitResult.Stop)
            {
                Tqx tqxSelected = (Tqx)tqsptTail.objCurrent(ivdData.imcGet());
#if DEBUG_PATH
                Console.WriteLine("Going forward");
#endif
                smc.Forward(tqxSelected.action); // Step forward.
                if (smc.fTerminated)
                {
#if DEBUG_PATH
                    Console.WriteLine("Path terminates");
#endif
                    fForward = false;
                }
                else if (rgtqtPath.Count >= (cMaxPathLength - 1))
                {
#if DEBUG_PATH
                    Console.WriteLine("At penultimate step");
#endif
                    // We have already generated the transitions from this state.
                    // We enter shutdown mode now so that when we generate transitions from the next state (when Count == cMaxPathLength)
                    // we will only generate shutdown transitions.
                    if (!smc.fActions) // 0 actions indicates everything is shutdown
                    {
#if DEBUG_PATH
                        Console.WriteLine("Actions");
#endif
                        fForward = false;
                    }
                    else
                    {
#if DEBUG_PATH
                        Console.WriteLine("Enter shutdown mode");
#endif
                        // need to continue on until in progress operations are terminated
                        smc.EnterShutdownMode();
                        fForward = true;
                    }
                }
                else
                    fForward = true;
                if (fForward)
                    goto AppendIterator; // Go prepare to take another step forward.
                else
                {
#if DEBUG_PATH
                    Console.WriteLine("Maximal rgPath found");
#endif
                    return KVisitResult.Stop; // Maximal rgPath based on the state machine terminating or max rgPath length reached.                   
                }

            }

            rgtqtPath.RemoveAt(rgtqtPath.Count - 1); // Must backtrack a step before we can go forward again.

        Backtracking:
#if DEBUG_PATH
            Console.WriteLine("Changing to backtracking mode");
#endif
            // Change to backtracking mode by setting fForward to false.
            if (fForward)
            {
                fForward = false;
#if DEBUG_PATH
                Console.WriteLine("Stopping - maximal rgPath since there are no transitions");
#endif
                return KVisitResult.Stop; // Maximal rgPath since there were no transitions from this state.
            }
            fForward = false;

        TestIfFinished:
            if (rgtqtPath.Count > 0)
            {
#if DEBUG_PATH
                Console.WriteLine("Backtracking");
#endif
                smc.Backtrack();
                goto NextEdge; // Try to generate the next forward step from the previous state.               
            }
            else
            {
#if DEBUG_PATH
                Console.WriteLine("Finished - all maximal paths have been found");
#endif
                return KVisitResult.Continue; // Finished. All maximal paths have already been found.
            }
        }
    }

    /*
     * Generate an instance of state machine model from a given initial state,
     * then generate random sequences of transitions through that machine for that model.
     */
    public class Tqspr : Tqsp
    {
        public Tqspr(Tqs tqsParent, Tqdp tqdp) : base(tqsParent, tqdp)
        {
        }

        public override KInitializeResult fDoInitialize(Ivd ivdData)
        {
            return base.fDoInitialize(ivdData);
        }

        public override KVisitResult fDoMoveNext(Ivd ivdData)
        {
            if (cMaxPathLength == 0)
                return KVisitResult.Stop; // Maximal rgPath since there were no transitions from this state.

            // Backtrack to the initial state.
            while (rgtqtPath.Count > 0)
            {
                smc.Backtrack();
                rgtqtPath.RemoveAt(rgtqtPath.Count - 1);
            }

        AppendIterator:
            // Append a new iterator so we can extend the rgPath from the current state.
            Debug.Assert(tqdDef != null);
            Tqspt tqsptNew = new Tqsptr(this, ((Tqdp)tqdDef).tqdpt, smc.CurrentState);
            if (tqsptNew.fInitialize(ivdData) != KInitializeResult.Failed)
                rgtqtPath.Add(tqsptNew);
            else
                return KVisitResult.Stop; // Maximal rgPath since there were no transitions from this state.

            // Get the next edge from the last iterator.
            Tqspt tqsptTail = rgtqtPath[rgtqtPath.Count - 1];
            if (tqsptTail.fMoveNext(ivdData) == KVisitResult.Stop)
            {
                Tqx tqxSelected = (Tqx)tqsptTail.objCurrent(ivdData.imcGet());
                smc.Forward(tqxSelected.action); // Step forward.
                if (smc.fTerminated)
                    return KVisitResult.Stop; // Maximal rgPath based on the state machine terminating.
                if (!smc.fActions)
                    return KVisitResult.Stop; // Maximal rgPath based on the transitions we are interested in.
                if (rgtqtPath.Count >= (cMaxPathLength - 1))
                {
                    // We have already generated the transitions from this state.
                    // We enter shutdown mode now so that when we generate transitions from the next state (when Count == cMaxPathLength)
                    // we will only generate shutdown transitions.

                    // need to continue on until in progress operations are terminated
                    smc.EnterShutdownMode();
                }
                goto AppendIterator; // Go prepare to take another step forward.
            }

            return KVisitResult.Stop; // Maximal rgPath since there were no transitions from this state.
        }
    }

    /*
     * Hold randomization state that is shared throughout Tqs tree so it can be restarted at known state.
     */
    public class Tqr
    {

        public readonly Random random;

        private static int iSharedSeed = 100;

        public Tqr()
        {
            random = new Random(iSharedSeed++);
        }

        public Tqr(int iSeed)
        {
            random = new Random(iSeed);
        }
    }

    public enum KVisitResult
    {
        Continue,
        Stop,
    }

    public enum KInitializeResult
    {
        Succeeded,
        Failed,
    }

    /*
     * Represents an action in a state machine.
     */
    public class Tqx
    {

        public readonly SMAction action;

        public Tqx(SMAction action)
        {
            this.action = action;
        }
    }
}
